Frontdoor
~~~~~~~~~~~
_[blue]#Max Wolfgang Filter <wolfgang.filter@ub.uni-stuttgart.de>#_

Die primäre Aufgabe des Frontdoor-Moduls ist die strukturierte Anzeige der Metadaten 
eines Dokuments. Weitere Aufgaben bestehen in der Bereitstellung von Zugängen für zusätzliche 
interne und externe Dienste (Mailkontakt, Hashüberprüfung, POD usw.)

Ausgangslage
^^^^^^^^^^^^^
Die Frontdoor (FD) bezieht die Metadaten aus dem OpusDocument-Modell. Die ausgegebenen Dokumentklassen können mit 
Hilfe der Funktion toArray() in ein mehrdimensionales Array ($doc_data) geschrieben werden, 
welches dann weiter verarbeitet werden kann.

FrontdoorController
^^^^^^^^^^^^^^^^^^^
Der FD-Controller ermittelt zunächst zum Dokument gehörende evtl. vorhandene Collections 
und bereitet sie für die Ausgabe vor. In einem weiteren Schritt werden die Schlüssel der Metadaten auf Existenz geprüft
(array_key_exists()) und, falls vorhanden, gezählt. Die ermittelte Anzahl wird dann an die View übergeben.
Eine Reduktion der auszugebenden Felder (Ausschluss privater Personendaten, interne Felder, usw.) 
wird über einen Filter mit Stopwortliste erreicht.  Das mehrdimensionale Array wird dann mit Hilfe rekursiver 
Iteration (RecursiveArrayIterator) in ein eindimensionales Array mit eindeutigen Schlüsselbezeichnungen
umgewandelt. Dieses wird nach Durchlauf eines Filters über unbesetzte Felder an die View übergeben ($mydoc_data). 
Ein Counter (Opus_Statistic_Local_Counter) zählt die Aufrufe des Dokuments und übermittelt die Daten ebenfalls an die View. 

FrontdoorView
^^^^^^^^^^^^^
Die View erhält ein eindimensionales Array mit alle besetzten und für die FD relevanten Feldern ($mydoc_data).
Die Ausgabe erfolgt nun in der Reihenfolge der Abfrage der einzelnen Schlüssel von $mydoc_data. 
Eine Abfrage prüft zunächst ob das Feld multipel ist oder nicht (das kann konfiguriert werden). 
Je nach Multiplizität liegen unterschiedliche Bezeichnungen des entsprechenden Schlüssels in $mydoc_data vor. 
Ist z.B. der Haupttitel multipel, lautet der entsprechende Schlüssel des ersten Titeleintrags in $mydoc_data
'TitleMain_0_Value', entsprechend für den zweiten Titel 'TitleMain_1_Value, usw.. Bei Singularität 
gibt es nur einen Schlüssel mit der Bezeichnung 'TitleMain_Value'. Diese Unterscheidung muss man bei der Feldabfrage
in der FD-View in jedem Fall abfangen. Im Falle der Multiplizität wird nun über alle Schlüssel 'TitleMain_$i_Value' 
iteriert und ausgeben. Die obere Iterationsgrenze ist durch die im FD-Controller ermittelte Anzahl der Werte zu einem Schlüssel gegeben
(für 'TitleMain' wäre das $i = 'titlenumber'). Ist der Schlüssel singulär, wird nur der entsprechende Wert
ausgegeben. Dieses Verfahren verlängert zwar den Code für die FD-View, ist aber zwingend, denn sonst werden 
wichtige Felder für die Ausgabe unterdrückt. 

Eine weitere Aufgabe der FD-View besteht in der Emöglichung des Zugangs zum Dokument oder der Dokumente. 
Falls ein Name des Dokuments existiert (array_key_exists(File_$i_Pathname)), wird ein entsprechendes Logo, 
entsprechend dem Typ des Dokuments, platziert. Typ und Dateigrösse werden ebenfalls (falls vorhanden) angezeigt.
Der (seltene) Fall, dass Metadaten zum Dokument existieren aber kein Dokument vorhanden ist, konnte bisher (31.07.2009) 
noch nicht berücksichtigt werden.

HashController/View
^^^^^^^^^^^^^^^^^^^
Der HashController hat die Aufgabe, die beim Hochladen des Dokumentes berechneten Hashwerte und Signaturen,
entgegenzunehmen und für die (Hash)View aufzuarbeiten. Dazu wird zunächst wieder über Opus_Document ein mehrdimensionales
Feld erzeugt ($doc_data). Die Informationen über Hashwerte stecken im Schlüssel 'File'. 
'File' wird ausgelesen und die Anzahl der vorliegenden Dateien gezählt. In der
folgenden Iteration werden alle vorliegenden Dateinamen sowie Hashwerte und Hashtypen in zwei Felder geschrieben, 
die dann an die View übergeben wird. Die Stuktur der Felder ist die folgende:

$filenames = {filename_0, filename_1, filename_3,...} und
$hashValueType = {hashtype_0_0 => hashvalue_0_0, hashtype_0_1 => hashvalue_0_1,...}.

Der erste Index steht für die Datei, der zweite Index für den entsprechenden Hashtyp und -wert. 

In der View werden die Felder dann entgegengenommen und ausgelesen Gleichzeitig erfolgt eine Überprüfung der Signaturen 
und Hashwerte und deren Darstellung. Hashwerte werden im Vergleich ausgegeben, für die Signaturen nur das Ergebnis 
der Überprüfung.

ContactmailController und MailController
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Diese beiden Controller und die zugehörigen Views dienen der Mailkommunikation von der Frontdoor aus.
Der ContactmailController liefert ein Formular zur Kontaktaufnahme mit dem Autor, falls dieser es erlaubt.
(AllowEmailContact = 1). In der Frontdoor-View wird dann neben dem Autor ein e-mail-Logo angezeigt, welches mit
dem ContactMailController verlinkt ist. Das Formular als solches wird mit der Klasse 'ContactmailForm' 
und der Funktion init() unter 'forms' generiert. Die Formularfelder 'Name' und 'Email Adresse' werden vorbesetzt 
(Zend_Form::populate()). Alle anderen Felder sind Pflichtfelder.

Der MailController dient der Empfehlung eines Dokuments. Er besitzt die gleiche Funktionalität wie der
ContactMailController. Eine Vorbesetzung von Feldern erfolgt hier nicht.



 